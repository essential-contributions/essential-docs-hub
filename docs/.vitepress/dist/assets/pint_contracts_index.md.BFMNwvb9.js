import{_ as n,c as r,a0 as s,G as e,B as o,o as i}from"./chunks/framework.DxQyBxTE.js";const h=JSON.parse('{"title":"Smart Contracts","description":"","frontmatter":{},"headers":[],"relativePath":"pint/contracts/index.md","filePath":"pint/contracts/index.md"}'),c={name:"pint/contracts/index.md"};function l(m,t,p,d,g,u){const a=o("ExternalContent");return i(),r("div",null,[t[0]||(t[0]=s('<h1 id="smart-contracts" tabindex="-1">Smart Contracts <a class="header-anchor" href="#smart-contracts" aria-label="Permalink to &quot;Smart Contracts&quot;">​</a></h1><p><strong>Pint</strong> is a language for writing &quot;smart contracts.&quot; If you are familiar with smart contract languages like Solidity, many elements of a Pint contract will feel familiar. However, at its core, Pint is fundamentally different from imperative smart contract languages. Writing smart contracts in Pint requires a different mindset for expressing the rules that the contract must enforce.</p><p>A <strong>Pint contract</strong> is a collection of <strong>predicates</strong>. Each predicate has:</p><ul><li>A <strong>name</strong></li><li>A <strong>list of typed parameters</strong></li><li>A <strong>list of constraints</strong></li></ul><p>Predicates in a smart contract define the various ways state can be mutated to accomplish specific tasks (e.g., a token transfer).</p><p>A contract may also contain a <strong>storage declaration</strong> that lists all storage variables owned by the contract. This <strong>contract storage</strong> serves as the contract’s database, where persistent state is maintained.</p>',6)),e(a,{url:"https://essential-contributions.github.io/pint/book/smart_contracts/index.html",selector:"main",subSelector:"h3#contract-structure"}),e(a,{url:"https://essential-contributions.github.io/pint/book/smart_contracts/index.html",selector:"main",subSelector:"h3#contract-interfaces"})])}const b=n(c,[["render",l]]);export{h as __pageData,b as default};
