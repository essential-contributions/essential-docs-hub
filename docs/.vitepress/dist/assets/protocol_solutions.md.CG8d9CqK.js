import{_ as t,c as e,a0 as s,o as n}from"./chunks/framework.TZSYhTdi.js";const m=JSON.parse('{"title":"Solutions","description":"","frontmatter":{},"headers":[],"relativePath":"protocol/solutions.md","filePath":"protocol/solutions.md"}'),a={name:"protocol/solutions.md"};function r(i,o,l,c,d,h){return n(),e("div",null,o[0]||(o[0]=[s('<h1 id="solutions" tabindex="-1">Solutions <a class="header-anchor" href="#solutions" aria-label="Permalink to &quot;Solutions&quot;">​</a></h1><p>A <strong>solution</strong> is the combination of:</p><ol><li><strong>User Data</strong> (the fixed constraints set by the user) and</li><li><strong>Solver-determined values</strong> (for the unconstrained parameters).</li></ol><p>By defining user data, the user effectively <strong>partially constrains</strong> the solution, describing what they want to happen in broad terms while leaving room for optimization by the solver.</p><p>In some cases, users may choose to <strong>fully constrain</strong> the solution within their user data, making only a single outcome valid. However, more commonly, they will leave some parameters unconstrained to allow solvers to fill in values. This enables flexibility, such as leaving room for <strong>solver fees</strong> or other dynamic conditions.</p><p>The <strong>solver’s role</strong> is to determine the values of these unconstrained decision variables to create a solution that satisfies all constraints (both the user&#39;s and the contract&#39;s), thereby enabling <strong>valid and optimized state changes</strong>.</p>',6)]))}const p=t(a,[["render",r]]);export{m as __pageData,p as default};
