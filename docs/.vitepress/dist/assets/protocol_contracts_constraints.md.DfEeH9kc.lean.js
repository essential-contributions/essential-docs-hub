import{_ as o,c as s,a0 as e,o as n}from"./chunks/framework.DxQyBxTE.js";const u=JSON.parse('{"title":"Constraints","description":"","frontmatter":{},"headers":[],"relativePath":"protocol/contracts/constraints.md","filePath":"protocol/contracts/constraints.md"}'),a={name:"protocol/contracts/constraints.md"};function r(i,t,c,l,p,d){return n(),s("div",null,t[0]||(t[0]=[e('<h1 id="constraints" tabindex="-1">Constraints <a class="header-anchor" href="#constraints" aria-label="Permalink to &quot;Constraints&quot;">​</a></h1><p><strong>Constraints</strong> are the foundational components of predicates. They are simply <strong>boolean expressions</strong> that need to evaluate to <strong>True</strong> for the predicate they’re part of to be satisfied.</p><p>Constraints can be used flexibly:</p><ul><li>A contract may define constraints directly for its state mutation.</li><li>Alternatively, it can apply constraints to state mutations on other contracts, requiring <strong>both sets of constraints</strong> to be satisfied.</li></ul><p>This flexibility enables <strong>efficient code reuse</strong>. For example, constraints governing a <strong>token swap</strong> can be deployed once and used across multiple applications. Additionally, users can apply <strong>User Data</strong> to further restrict the solution space of a predicate, which is covered in-depth in the chapter on <strong>User Data and Solutions</strong>.</p>',5)]))}const h=o(a,[["render",r]]);export{u as __pageData,h as default};
