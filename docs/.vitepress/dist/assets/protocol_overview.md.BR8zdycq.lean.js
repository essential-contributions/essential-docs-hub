import{_ as o,c as e,a0 as i,o as s}from"./chunks/framework.DxQyBxTE.js";const h=JSON.parse('{"title":"Overview","description":"","frontmatter":{},"headers":[],"relativePath":"protocol/overview.md","filePath":"protocol/overview.md"}'),n={name:"protocol/overview.md"};function a(r,t,l,c,d,p){return s(),e("div",null,t[0]||(t[0]=[i('<h1 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h1><p>Essential is the first <strong>declarative blockchain protocol</strong>, implementing the declarative principles in a decentralized, permissionless system. The protocol is designed around the concept of <strong>blocks as pure state mutations</strong>.</p><p>State mutations are introduced as <strong>solutions</strong> provided by solvers. A <strong>solver</strong> could be:</p><ul><li>A third-party entity competing to find optimal solutions, or</li><li>A centralized program (such as a server, front-end app, or wallet) providing solutions for a specific application.</li></ul><p>In contrast to solutions in an imperative system, which consist of a sequence of ordered transactions, solutions in a declarative system are merely <strong>lists of state mutations</strong>.</p><h3 id="from-solutions-to-state" tabindex="-1">From Solutions to State <a class="header-anchor" href="#from-solutions-to-state" aria-label="Permalink to &quot;From Solutions to State&quot;">​</a></h3><p><strong>Validation</strong> is the process by which solutions become state:</p><ul><li>A solution is considered valid if it satisfies all the contracts whose state it mutates.</li><li>Only valid solutions are then considered for inclusion in the next block.</li></ul><h3 id="inclusion-and-bidding-mechanism" tabindex="-1">Inclusion and Bidding Mechanism <a class="header-anchor" href="#inclusion-and-bidding-mechanism" aria-label="Permalink to &quot;Inclusion and Bidding Mechanism&quot;">​</a></h3><p>Inclusion in the next block happens via an out-of-protocol mechanism where <strong>solvers bid</strong> for inclusion with a solution aggregator (similar to a block builder). These <strong>bids for inclusion</strong> are expressed as <strong>constraints on state</strong>. The protocol itself, however, only concerns itself with the <strong>validity of solutions</strong>. Optimality is driven by <strong>auction dynamics</strong> at both the application and solution aggregation level.</p><p>In the following section, we will explore how contracts are structured to define conditions under which their state can be mutated.</p>',11)]))}const m=o(n,[["render",a]]);export{h as __pageData,m as default};
